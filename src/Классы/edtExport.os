#Использовать logos
#Использовать v8metadata-reader

Перем _Лог;
Перем _РезультатПроверки;
Перем _ФайлДжсон;
Перем _КаталогИсходников;
Перем _ВыгружатьОшибкиОбъектов;
Перем _путьКИсключениям;
Перем ГенераторПутей;

Процедура ОписаниеКоманды(Команда) Экспорт
	
	Команда.Аргумент("EDT_VALIDATION_RESULT", "", "Путь к файлу с результатом проверки edt. Например ./edt-result.out")
		.ТСтрока()
		.ВОкружении("EDT_VALIDATION_RESULT");
	
	Команда.Аргумент("EDT_VALIDATION_JSON", "", "Путь к файлу результату. Например ./edt-json.json")
		.ТСтрока()
		.ВОкружении("EDT_VALIDATION_JSON");
	
	Команда.Аргумент("SRC", "", "Путь к каталогу с исходниками. Например ./src")
		.ТСтрока()
		.ВОкружении("SRC");

	Команда.Аргумент("EDT_EXCLUSION", "", "Путь к файлу исключений")
		.ТСтрока()
		.Обязательный(Ложь)
		.ВОкружении("EDT_EXCLUSION");

	
	Команда.Опция("e ObjectErrors", Ложь, "Ошибки объектов назначать на первую строку модуля формы/объекта");
	
КонецПроцедуры

Процедура ВыполнитьКоманду(Знач Команда) Экспорт
	
	ИнициализацияПараметров(Команда);
	
	таблицаРезультатов = ТаблицаПоФайлуРезультата();
	
	ФильтроватьРезультаты(таблицаРезультатов);

	ЗаполнитьВТаблицеРезультатовИсходныеПути(таблицаРезультатов);
	ЗаполнитьВТаблицеРезультатовНомераСтрок(таблицаРезультатов);
	
	записьВДжсон = Новый ЗаписьReportJSON(_ФайлДжсон, _Лог);
	записьВДжсон.Записать(таблицаРезультатов);
	
КонецПроцедуры

Процедура ИнициализацияПараметров(Знач Команда)
	
	результатПроверки = Команда.ЗначениеАргумента("EDT_VALIDATION_RESULT");
	_лог.Отладка("EDT_VALIDATION_RESULT = " + результатПроверки);
	путьКРезультату = Команда.ЗначениеАргумента("EDT_VALIDATION_JSON");
	_лог.Отладка("EDT_VALIDATION_JSON = " + путьКРезультату);
	путьККаталогуИсходников = Команда.ЗначениеАргумента("SRC");
	_лог.Отладка("SRC = " + путьККаталогуИсходников);
	путьКИсключениям = Команда.ЗначениеАргумента("EDT_EXCLUSION");
	_лог.Отладка("EDT_EXCLUSION = " + путьКИсключениям);
	
	_РезультатПроверки = ОбщегоНазначения.АбсолютныйПуть(результатПроверки);
	_лог.Отладка("Файл с результатом проверки EDT = " + _РезультатПроверки);
	
	Если Не ОбщегоНазначения.ФайлСуществует(_РезультатПроверки) Тогда
		
		_лог.Ошибка(СтрШаблон("Файл с результатом проверки <%1> не существует.", результатПроверки));
		ЗавершитьРаботу(1);
		
	КонецЕсли;
	
	_КаталогИсходников = ОбщегоНазначения.АбсолютныйПуть(путьККаталогуИсходников);
	каталогИсходников  = Новый Файл(_КаталогИсходников);
	_лог.Отладка("Каталог исходников = " + _КаталогИсходников);
	
	Если Не каталогИсходников.Существует()
		Или Не каталогИсходников.ЭтоКаталог() Тогда
		
		_лог.Ошибка(СтрШаблон("Каталог исходников <%1> не существует.", путьККаталогуИсходников));
		ЗавершитьРаботу(1);
		
	КонецЕсли;
	
	_ФайлДжсон = ОбщегоНазначения.АбсолютныйПуть(путьКРезультату);
	_лог.Отладка("Файл результат = " + _ФайлДжсон);

	Если НЕ ПустаяСтрока(путьКИсключениям) Тогда
		_путьКИсключениям =  ОбщегоНазначения.АбсолютныйПуть(путьКИсключениям);
		_лог.Отладка("Файл с исключениями EDT = " + _путьКИсключениям);
	
		Если Не ОбщегоНазначения.ФайлСуществует(_путьКИсключениям) Тогда
		
			_лог.Ошибка(СтрШаблон("Файл с исключениями <%1> задан, но не существует.", путьКИсключениям));
			ЗавершитьРаботу(1);
		
		КонецЕсли;
	КонецЕсли;
	
	_ВыгружатьОшибкиОбъектов = Команда.ЗначениеОпции("ObjectErrors");
	
	ГенераторПутей = Новый Путь1СПоМетаданным(_КаталогИсходников);
	
КонецПроцедуры

Функция ТаблицаПоФайлуРезультата()
	
	разделительВФайле = "	";
	кодировкаФайла = КодировкаТекста.UTF8;

	_Лог.Отладка("Чтение файла результата %1", _РезультатПроверки);
	
	тз = Новый ТаблицаЗначений;
	тз.Колонки.Добавить("ДатаОбнаружения");
	тз.Колонки.Добавить("Тип");
	тз.Колонки.Добавить("Проект");
	тз.Колонки.Добавить("Правило");
	
	тз.Колонки.Добавить("Метаданные");
	тз.Колонки.Добавить("Положение");
	тз.Колонки.Добавить("Описание");
	тз.Колонки.Добавить("Отфильтровать");
	
	ЧтениеТекста = Новый ЧтениеТекста(_РезультатПроверки, кодировкаФайла);
	
	данныеФайла = ЧтениеCSV.ПрочитатьИзТекста(ЧтениеТекста, разделительВФайле);
	
	ЧтениеТекста.Закрыть();

	всегоОшибок = 0;

	Исключения = МассивИсключений();

	Если данныеФайла.Количество() = 0 Тогда

		_Лог.Информация("Из файла %1 прочитано %2 строк из %3", _РезультатПроверки, данныеФайла.Количество(), всегоОшибок);
		Возврат тз;

	КонецЕсли;

	перваяСтрока = данныеФайла[0];

	именаПолей = Новый Структура();

	именаПолей.Вставить("ДатаОбнаружения", 0);
	именаПолей.Вставить("Тип", 1);
	именаПолей.Вставить("Проект", 2);

	сдвиг = 0;

	Если перваяСтрока.Количество() = 7 Тогда

		// В 2021.2 добавили новую колонку
		именаПолей.Вставить("Правило", 3);
		сдвиг = 1;

	КонецЕсли;

	именаПолей.Вставить("Метаданные", 3 + сдвиг);
	именаПолей.Вставить("Положение", 4 + сдвиг);
	именаПолей.Вставить("Описание", 5 + сдвиг);

	Для каждого цПоля Из данныеФайла Цикл

		Если цПоля.Количество() = 0 Тогда
			Продолжить;
		КонецЕсли;

		всегоОшибок = всегоОшибок + 1;
		
		положение = цПоля[именаПолей.Положение];
		
		Если Не _ВыгружатьОшибкиОбъектов
			И (Не ЗначениеЗаполнено(положение)
			ИЛИ Не СтрНачинаетсяС(ВРег(положение), "СТРОКА")) Тогда
			
			// Нас интересуют только ошибки в модулях, а у них есть положение.
			Продолжить;
			
		КонецЕсли;
		
		описание = цПоля[именаПолей.Описание];
		
		Если ЗначениеЗаполнено(описание)
			И СтрНачинаетсяС(описание, "[BSL LS]") Тогда
			
			// Пропускаем ошибки от плагина, т.к. BSL-LS отдельно выполняет проверку
			Продолжить;
			
		КонецЕсли;
		
		новСтрока = тз.Добавить();
		
		Для каждого цКлючИЗначение Из именаПолей Цикл
			
			новСтрока[цКлючИЗначение.Ключ] = цПоля[цКлючИЗначение.Значение];
			
		КонецЦикла;
		новСтрока.Отфильтровать  = ИсключитьСтроку(новСтрока.Описание,  Исключения);
		ПереопределитьПути(новСтрока);
		
	КонецЦикла;
	
	_Лог.Информация("Из файла %1 прочитано %2 строк из %3", _РезультатПроверки, тз.Количество(), всегоОшибок);
	
	// В отчете могут быть дубли
	
	тз.Свернуть("Правило,Тип,Метаданные,Положение,Описание,Отфильтровать");
	
	Возврат тз;
	
КонецФункции

Функция ИсключитьСтроку(Текст, Исключения) 

	
	Если НЕ ЗначениеЗаполнено(Текст) ИЛИ НЕ ЗначениеЗаполнено(Исключения) Тогда
		Возврат Ложь;
	КонецЕсли;

	Для Каждого Элемент ИЗ Исключения Цикл
		Если СтрНайти(НРег(Текст), Элемент) > 0 Тогда

			Возврат Истина;

		КонецЕсли;
	КонецЦикла;

	Возврат Ложь;

КонецФункции

Функция МассивИсключений()

	Исключения = Новый Массив;

	Если НЕ ЗначениеЗаполнено(_путьКИсключениям) Тогда
		Возврат Исключения;
	КонецЕсли;
	
	Чтение = Новый ЧтениеТекста();
	Чтение.Открыть(_путьКИсключениям, КодировкаТекста.UTF8);
	Строка = Чтение.ПрочитатьСтроку();

	Пока Строка <> Неопределено Цикл 

		Исключения.Добавить(СокрЛП(НРЕГ(Строка)));

        Строка = Чтение.ПрочитатьСтроку();             

	КонецЦикла;
	Чтение.Закрыть();

 Возврат Исключения; 
КонецФункции

Процедура ФильтроватьРезультаты(таблицаРезультатов)

	УдаляемыеСтроки = таблицаРезультатов.НайтиСтроки(Новый Структура("Отфильтровать", Истина));

	Для каждого Строка из УдаляемыеСтроки Цикл
		_Лог.Отладка("Удалена ошибка %1",  Строка.Описание);
	
		таблицаРезультатов.Удалить(Строка);
	КонецЦикла;

КонецПроцедуры

Процедура ПереопределитьПути(СтрокаТаблицы)
	
	Если Не _ВыгружатьОшибкиОбъектов Тогда
		
		Возврат;
		
	КонецЕсли;
	
	Если СтрНачинаетсяС(ВРег(СтрокаТаблицы.Положение), "СТРОКА") Тогда
		
		Возврат;
		
	КонецЕсли;
	
	мета = СтрокаТаблицы.Метаданные;
	
	Если СтрЗаканчиваетсяНа(ВРег(мета), ".ФОРМА") Тогда
		
		// Вешаем на модуль формы
		
		СтрокаТаблицы.Метаданные = мета + ".Модуль";
		
	ИначеЕсли СтрРазделить(мета, ".").Количество() = 2 Тогда
		
		Если ПутьКМетаданнымСуществует(мета + ".МодульОбъекта") Тогда
			
			СтрокаТаблицы.Метаданные = мета + ".МодульОбъекта";
			
		ИначеЕсли ПутьКМетаданнымСуществует(мета + ".МодульМенеджера") Тогда
			
			СтрокаТаблицы.Метаданные = мета + ".МодульМенеджера";
			
		ИначеЕсли ПутьКМетаданнымСуществует(мета + ".МодульНабораЗаписей") Тогда
			
			СтрокаТаблицы.Метаданные = мета + ".МодульНабораЗаписей";
			
		ИначеЕсли ПутьКМетаданнымСуществует(мета + ".МодульМенеджераЗначения") Тогда
			
			СтрокаТаблицы.Метаданные = мета + ".МодульМенеджераЗначения";
			
		ИначеЕсли ПутьКМетаданнымСуществует(мета + ".МодульКоманды") Тогда
			
			СтрокаТаблицы.Метаданные = мета + ".МодульКоманды";
			
		Иначе
			
			СтрокаТаблицы.Метаданные     = "Конфигурация.МодульУправляемогоПриложения";
			СтрокаТаблицы.Описание = мета + ": " + СтрокаТаблицы.Описание;
			
		КонецЕсли;
		
	ИначеЕсли СтрНачинаетсяС(ВРег(мета), "ПОДСИСТЕМА.") Тогда
		
		СтрокаТаблицы.Метаданные     = "Конфигурация.МодульУправляемогоПриложения";
		СтрокаТаблицы.Описание = мета + ": " + СтрокаТаблицы.Описание;
		
	Иначе
		
		_Лог.Предупреждение("Не переопределен путь для %1", мета);
		
		СтрокаТаблицы.Метаданные     = "Конфигурация.МодульУправляемогоПриложения";
		СтрокаТаблицы.Описание = мета + ": " + СтрокаТаблицы.Описание;
		
	КонецЕсли;
	
	СтрокаТаблицы.Положение = "Строка 1";
	
КонецПроцедуры

Процедура ЗаполнитьВТаблицеРезультатовИсходныеПути(таблицаРезультатов)
	
	таблицаРезультатов.Колонки.Добавить("Путь");
	
	Для каждого цСтрока Из таблицаРезультатов Цикл
		
		цСтрока.Путь = генераторПутей.Путь(цСтрока.Метаданные);
		
		Если Не ПроверитьПуть(цСтрока.Путь, цСтрока.Метаданные) Тогда
			
			цСтрока.Путь = "";
			
		КонецЕсли;
		
	КонецЦикла;
	
	поискСтрокКУдалению = Новый Структура("Путь", "");
	
	Для каждого цСтрокаКУдалению Из таблицаРезультатов.НайтиСтроки(поискСтрокКУдалению) Цикл
		
		таблицаРезультатов.Удалить(цСтрокаКУдалению);
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьВТаблицеРезультатовНомераСтрок(таблицаРезультатов)
	
	таблицаРезультатов.Колонки.Добавить("НомерСтроки");
	
	Для каждого цСтрока Из таблицаРезультатов Цикл
		
		цСтрока.НомерСтроки = СтрЗаменить(ВРег(цСтрока.Положение), "СТРОКА ", "");
		
	КонецЦикла;
	
КонецПроцедуры

Функция ПутьКМетаданнымСуществует(Знач пМетаданные)
	
	Путь = генераторПутей.Путь(пМетаданные);
	
	Возврат ПроверитьПуть(Путь, пМетаданные, Ложь);
	
КонецФункции

Функция ПроверитьПуть(Знач пПуть, Знач пМетаданные = "", Знач пСообщать = Истина)
	
	Если Не ЗначениеЗаполнено(пПуть) Тогда
		
		Если пСообщать Тогда
			
			_лог.Ошибка(СтрШаблон("Путь для <%1> не получен", пМетаданные));
			
		КонецЕсли;
		
		Возврат Ложь;
		
	ИначеЕсли Не ОбщегоНазначения.ФайлСуществует(пПуть) Тогда
		
		Если пСообщать Тогда
			
			_лог.Ошибка(СтрШаблон("Путь <%1> для <%2> не существует", пПуть, пМетаданные));
			
		КонецЕсли;
		
		Возврат Ложь;
		
	Иначе
		
		Возврат Истина;
		
	КонецЕсли;
	
КонецФункции

Функция ИмяЛога() Экспорт
	
	Возврат "oscript.app." + ОПриложении.Имя();

КонецФункции

_Лог = Логирование.ПолучитьЛог(ИмяЛога());